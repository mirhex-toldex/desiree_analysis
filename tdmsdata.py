from matplotlib.pyplot import colormaps
from nptdms import TdmsFile
import numpy as np

class TdmsData(object):

    def __init__(self,path):
        '''
        Class to access data from tdms files. The tdms structure is based on
        "groups" of data, where the actual data is labelled "channel". For our
        purpose, the "group" property is the "channel" on the data collection.
        (this naming convention is very unfortunate for our case, but we are 
        stuck with it). The "channels" in our case correspond to different
        measured quantities of the event, which always includes cycle number
        and time, but can also include other properties such as laser properties.

        Possible groups are:
        'Channel 0', 'Channel 2',..., 'Channel 9'  

        with the corresponding channels:
        'Cycle No.', 'Time (s)', etc..
        '''
        self.filepath = path
        self.fileobject = TdmsFile.read_metadata(path)

        
        self.groups = self.fileobject.groups()
        self.fileinfo = ''
        for i in self.fileobject.properties :
            self.fileinfo += '{} : {}\n'.format(i,self.fileobject.properties[i])

        self.groupnames = []
        self.groupchannels = {}   
        self.groupdescriptions = {}     
        for g in self.groups:
            channels = [c.name for c in g.channels()]
            self.groupchannels[g.name] = channels
            self.groupdescriptions[g.name] = g.properties['Description']
            self.groupnames.append(g.name)

    def get_data_dimensions(self,groupname):
        '''
        Returns the dimensions of the data in a group. Requires reading
        full data array in memory.
        '''
        with TdmsFile.open(self.filepath) as f : 
            try : 
                return f[groupname]['Cycle No.'][:].shape[0]
            except KeyError:
                return None


    def get_raw_data(self,groupname):
        '''
        Returns a 2D numpy array with the raw data
        of a a group
        '''

        channels = self.groupchannels[groupname]

        with TdmsFile.open(self.filepath) as f:
            for i,c in enumerate(channels):
                c_data = f[groupname][c][:]

                try:
                    data[:,i] = c_data
                except NameError :
                    data = np.empty((c_data.shape[0],len(channels)))
                    data[:,i] = c_data

        return data

    def get_last_event_time(self,groupname) :
        with TdmsFile.open(self.filepath) as f:
            try :
                t = np.max(f[groupname]['Time (s)'][:])
            except KeyError : 
                t = None
        return t

    def get_global_max_time(self) :
        gmax = 0
        for g in self.groupnames :
            t = self.get_last_event_time(g)
            if t is None :
                continue
            
            if t > gmax :
                gmax = t
        
        return gmax           


    def bin_data(self,group,channel,histbins,skip=[],cycle_indices=None):
        """
        Method to bin data.
        Arguments:
        group - str, group name
        channel - str, channel name
        histbins - array-like, bin edges of histogram (see numpy.histogram documentation)
        skip - array-like, skip cycles in this list
        cycle_indices - cycle-index map generated by method "get_cycle_indices", this
        argument is necessary of cycles are to be skipped.
        
        Returns:
        y - array, number of events in each bin
        """

        with TdmsFile.open(self.filepath) as f:
              
                if len(skip) > 0 :
                    data = []
                    for c in cycle_indices :
                        if c not in skip :
                            start = cycle_indices[c][0]
                            stop = cycle_indices[c][1]
                            data.append(f[group][channel][start:stop])
                    
                    data = np.concatenate(data)

                else :
                    data = f[group][channel][:]
                y,_ = np.histogram(data,histbins)
        
        return y

    def bin_2D(self,group,channel1,channel2,channel1bins,channel2bins,skip=[],cycle_indices=None) :
        with TdmsFile.open(self.filepath) as f:
            
            if len(skip) > 0 :
                data1 = []
                data2 = []
                for c in cycle_indices :
                    if c not in skip :
                        start = cycle_indices[c][0]
                        stop = cycle_indices[c][1]
                        data1.append(f[group][channel1][start:stop])
                        data2.append(f[group][channel2][start:stop])
                
                data1 = np.concatenate(data1)
                data2 = np.concatenate(data2)


            else :
                data1 = f[group][channel1][:]
                data2 = f[group][channel2][:]

            h,_,__ = np.histogram2d(data1,data2,[channel1bins,channel2bins])

        return h

    def get_cycle_indices(self,groupname):
        """
        Generate a dictionary where the keys are cycle numbers.
        Values are tuples of length 2, corresponding to the start and
        stop indices of the data array corresponding to the cycle number.
        By using this dictionary, each cycle can be read separately, which
        can make memory use a bit more efficient.
        cycle_indices = {1 : (0,43), 2 : (43,78), ...}
        Arguments:
        groupname - str, name of group
        Returns:
        cycle_indices - dict described above
        """
        cycle_indices = {}
  
        with TdmsFile.open(self.filepath) as f:

            startindex = 0
            current_cycle = int(f[groupname]['Cycle No.'][startindex])
            for i,c in enumerate(f[groupname]['Cycle No.']):
                cycle = int(c)
                if cycle != current_cycle :
                    cycle_indices[current_cycle] = (startindex,i)
                    startindex = i
                    current_cycle = cycle
        
        # the last cycle causes some trouble
        # I think the +1 solves it but im not 100%
        cycle_indices[current_cycle] = (startindex,i+1)

        return cycle_indices

    def get_wavelength_map(self,groupname,cycle_indices):
        """
        Create a dictionary where the keys are recorded wavelengths and
        the values are lists of cycle numbers, e. g.
        wavemap = {632.0 : [1,4,7],634.0 : [2,5,8], 636.0 : [3,6,9]}
        Used to handle laser scanning where the wavelength switches 
        on every cycle.

        Note: assigns the wavelength from the last event in the cycle.
        This might be a bit unsafe if something strange happens. Might
        be safer to use a larger piece of the data set.
        Arguments:
        cycle_indices, dict, see method "get_cycle_indices"
        """
        wavemap = {}

        with TdmsFile.open(self.filepath) as f:
            for cycle in cycle_indices:
                # the minus 1 is due to the python list slicing
                # for example if you take list[3] you get the fourth
                # element but if you do list[0:3] you get the zeroth
                # to third element only
                # the indices returned by method get_cycle_indices
                # are intended for slicing, so the -1 is necessary
                # in order not to go out of bounds
                # stop = cycle_indices[cycle][1] - 1 
                stop = int((cycle_indices[cycle][1] + cycle_indices[cycle][0])*.5) 
                # stop = cycle_indices[cycle][0]  
            

                wave = f[groupname]['Wavelength (nm)'][stop]
                
                try :
                    wavemap[wave].append(cycle)
                except KeyError :
                    wavemap[wave] = [cycle]

        return wavemap

    def bin_per_wavelength(self,groupname,cycle_indices,wavelength_map,histbins,skip=[]) :
        '''
        Bin data of group per wavelength as given in wavelength_map.

        Arguments: 
        group - str, group name
        histbins - array-like, bin edges of histogram (see numpy.histogram documentation)
        skip - array-like, skip cycles in this list
        cycle_indices - cycle-index map generated by method "get_cycle_indices", this
        argument is necessary of cycles are to be skipped.
        
        Returns:
        binneddata - numpy array, with dimensions (number of bins, number of wavelengths)

        Notes: the 'Time (s)' channel is hardcoded for this function. Can be updated if
        some other channel should be binned.
        '''

        N_wavelengths = len(wavelength_map)
        binneddata = np.zeros((histbins.shape[0]-1,(N_wavelengths)))
        wave_sorted = sorted(list(wavelength_map.keys()))

        with TdmsFile.open(self.filepath) as f:

            for i,wave in enumerate(wave_sorted):
                allevents = []

                for cycle in wavelength_map[wave] :
                    if cycle not in skip :
                        try:
                            startindex = cycle_indices[cycle][0]
                            stopindex = cycle_indices[cycle][1]
                            times = f[groupname]['Time (s)'][startindex:stopindex]
                            allevents.append(times)
                        except KeyError :
                            continue

                y,_ = np.histogram(np.concatenate(allevents),histbins)
                binneddata[:,i] = y

        return binneddata

    
    def bin_per_wavelength_direct(self,groupname,cycle_indices,histbins,skip=[]) :
        wavelengths = self.get_unique_wavelengths(groupname)
        data = {}
        for w in wavelengths :
            data[w] = np.zeros(len(histbins)-1)


        with TdmsFile.open(self.filepath) as f:
            for cycle in cycle_indices :
                if cycle in skip :
                    continue

                start = cycle_indices[cycle][0]
                stop = cycle_indices[cycle][1]

                time = f[groupname]['Time (s)'][start:stop]
                wave = f[groupname]['Wavelength (nm)'][start:stop]
                # print(wave)
                for w in wavelengths :
                    ind = wave == w 

                    if ind.any() :
                        y,_ = np.histogram(time[ind],histbins)
                        data[w] += y


        binneddata = np.empty((len(histbins)-1,(len(wavelengths))))
        for i,w in enumerate(sorted(wavelengths)) :
            binneddata[:,i] = data[w]

        return binneddata

    def get_unique_wavelengths(self,groupname):
        wavelenghts = set()
        with TdmsFile.open(self.filepath) as f:
            for w in f[groupname]['Wavelength (nm)']:
                wavelenghts.add(w)

        return wavelenghts


    def __str__(self) :
        s = ''
        for g in self.groupchannels.keys() :
            s += (g + ' - ' + self.groupdescriptions[g] + 
                ' - ' + str(self.groupchannels[g]) + '\n')

        return s

def main() : 
    filename = '/Users/xnimir/Desktop/Sn exp/Week47_17-11-2023/Isotope shift/20231124_0955_Sn_116_res_scan.tdms'
    t = TdmsData(filename)
    

if __name__ == '__main__' :
    main()